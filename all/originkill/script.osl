// setup the window
window.framerate = 60
window.no_desktop = true
window "responsive" true
window "fullscreen" false
if passed_data == "" (
  window "set_dragbox" [[0,0,0,0],[0,0,0,0]]
  window "resizable" false
  window "dimensions" 800 800
)
window "min_size" 100 100
window.x = 0
window.y = 0

wintype = passed_data.str

urlback = "https://raw.githubusercontent.com/ThePandaDever/AssetStore/refs/heads/main/OriginWindowKill/"

// sounds
sound urlback ++ "3%20-%20Windowkiller.mp3" "load" "ost1"
sound "ost1" "volume" 25
sound urlback ++ "shoot2.ogg" "load" "shoot"
sound "shoot" "volume" 50
sound urlback ++ "enemyDie.ogg" "load" "enemyDie"
sound "enemyDie" "volume" 100
sound urlback ++ "playerHit.ogg" "load" "playerHit"
sound urlback ++ "hit3.ogg" "load" "enemyHit"
sound "enemyHit" "volume" 100
sound urlback ++ "hitWall.ogg" "load" "hitWall"
sound "hitWall" "volume" 25
sound urlback ++ "hitWall2.ogg" "load" "hitWall2"
sound "hitWall2" "volume" 75

// coins
sound urlback ++ "coin1.ogg" "load" "blob1"
sound urlback ++ "coin2.ogg" "load" "blob2"
sound urlback ++ "coin3.ogg" "load" "blob3"
sound urlback ++ "coin4.ogg" "load" "blob4"
sound urlback ++ "coin5.ogg" "load" "blob5"

// all the upgrade icns
up_speed = "w 2 c #fff cutcircle 4.5 0 6.5 0 180 c #444 w 2.5 line -9.5 -5 -4 -5 line -11 0 -6 0 line -9.5 5 -4 5"
up_firerate = "w 2 c #fff ellipse 5.5 2.5 .9 2 90 ellipse -1.5 2.5 .9 2 90 ellipse -5.5 -2.5 .9 2 90 ellipse 1.5 -2.5 .9 2 90"
up_multishot = "w 2 c #fff cutcircle 0 -12 6.5 0 90 w 1.6 c #fff ellipse 0 -.5 .8 2 0 ellipse 0 5.5 .8 2 0 c #2f2 ellipse 5.5 -1.5 .8 2 20 ellipse 7.75 4.5 .8 2 20 ellipse -5.5 -1.5 .8 2 -20 ellipse -7.75 4.5 .8 2 -20"
up_wealth = "w 2 c #fff line 0 -3 0 3 line -3 0 3 0  c #a833ff cutcircle 0 0 10 0 0 cutcircle 0 0 10 2 0 cutcircle 0 0 10 4 0 cutcircle 0 0 10 6 0 cutcircle 0 0 10 8 0 cutcircle 0 0 10 10 0 cutcircle 0 0 10 12 0 cutcircle 0 0 10 14 0 cutcircle 0 0 10 16 0 cutcircle 0 0 10 18 0 cutcircle 0 0 10 20 0 cutcircle 0 0 10 22 0 cutcircle 0 0 10 24 0 cutcircle 0 0 10 26 0 cutcircle 0 0 10 28 0 cutcircle 0 0 10 30 0 cutcircle 0 0 10 32 0 cutcircle 0 0 10 34 0"
up_wallpunch = "w 1.6 c #fff line 4 10 4 -10  c #ffdb1d line 1.5 3 -1 7 line -2.5 2.5 -6 3.5 line -5 -2 -8 -3.5 line 1.5 -3 -1 -6.5  w 1.6 c #fff ellipse 0 0 .8 2 90"
up_piercing = "w 2 c #333 ellipse -3 -6 1 2 30 w 2 c #999 ellipse 0 -.5 1 2 40 w 2 c #fff ellipse 6 4 1 2 65 c #fc0 w 2 line 1 7 6 -7 cont -8 -3 cont 1 7"
up_heal = "w 2 c #0f0 line 0 -2.5 0 2.5 line -2.5 0 2.5 0  w 2 c #fff cutcircle 7 4.5 2 4.5 45 cutcircle 7 -4.5 2 13.5 45 cutcircle -7 -4.5 2 22.5 45 cutcircle -7 4.5 2 31.5 45 line -7 6.5 7 6.5 line -7 -6.5 7 -6.5 line -9 4.5 -9 -4.5 line 9 4.5 9 -4.5"
up_maxhealth = "w 2 c #0f0 line 0 -2.5 0 2.5 line -2.5 0 2.5 0  w 1.5 cutcircle 0 0 9 0 6.5 cutcircle 0 0 9 4.5 6.5 cutcircle 0 0 9 9 6.5 cutcircle 0 0 9 13.5 6.5 cutcircle 0 0 9 18 6.5 cutcircle 0 0 9 22.5 6.5 cutcircle 0 0 9 27 6.5 cutcircle 0 0 9 31.5 6.5  w 2  c #fff cutcircle 0 0 6.5 0 180"

// upgrades:
// [cost,variable,operation,number]
// OR
// [cost,[[variable,operation,number]]]
// the 2nd item being all the operations
upgrades = {
  "speed":[15,"player_speed","+",0.25],
  "firerate":[42,"bullet_cooldown","-",1],
  "multishot":[152,"bullet_spread","+",1],
  "wealth":[52,"currencymult","+",.25],
  "wallpunch":[38,"window_force","+",1],
  "piercing":[62,"bullet_uses","+",1],
  "heal":[36,"player_health","+",20],
  "maxhealth":[30,[["player_max_health","+",5],["player_health","+",5]]]
}
actions = [
  "heal"
]
// the text displayed for each upgrade
upgrade_text = {
  "speed":"speed",
  "firerate":"fire rate",
  "multishot":"+1 multi shot",
  "wealth":"wealth",
  "wallpunch":"wall punch",
  "piercing":"piercing",
  "heal":"heal 20",
  "maxhealth":"max health"
}

// hex array, used for entityC
hex = [
  "00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0A", "0B", "0C", "0D", "0E", "0F",
  "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1A", "1B", "1C", "1D", "1E", "1F",
  "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2A", "2B", "2C", "2D", "2E", "2F",
  "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3A", "3B", "3C", "3D", "3E", "3F",
  "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4A", "4B", "4C", "4D", "4E", "4F",
  "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5A", "5B", "5C", "5D", "5E", "5F",
  "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6A", "6B", "6C", "6D", "6E", "6F",
  "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7A", "7B", "7C", "7D", "7E", "7F",
  "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8A", "8B", "8C", "8D", "8E", "8F",
  "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9A", "9B", "9C", "9D", "9E", "9F",
  "A0", "A1", "A2", "A3", "A4", "A5", "A6", "A7", "A8", "A9", "AA", "AB", "AC", "AD", "AE", "AF",
  "B0", "B1", "B2", "B3", "B4", "B5", "B6", "B7", "B8", "B9", "BA", "BB", "BC", "BD", "BE", "BF",
  "C0", "C1", "C2", "C3", "C4", "C5", "C6", "C7", "C8", "C9", "CA", "CB", "CC", "CD", "CE", "CF",
  "D0", "D1", "D2", "D3", "D4", "D5", "D6", "D7", "D8", "D9", "DA", "DB", "DC", "DD", "DE", "DF",
  "E0", "E1", "E2", "E3", "E4", "E5", "E6", "E7", "E8", "E9", "EA", "EB", "EC", "ED", "EE", "EF",
  "F0", "F1", "F2", "F3", "F4", "F5", "F6", "F7", "F8", "F9", "FA", "FB", "FC", "FD", "FE", "FF"
]

if passed_data == "" (
  // if its the main window, the if isnt really needed
  play_ost = true
)

def "newEntRaw" "id,x,y,isboss" (
  if id == "wyrm" (
    rx = x
    ry = y
    wyrmi = 0
    loop random(2,4) (
      wyrmi ++
      newEntRaw2 id rx ry isboss
      enteee = entities[enid]
      enteee.append({ "parent":lastseg, "attackTime":0, "wyrmi": wyrmi, "ishead": wyrmi == 1 })
      enteee[7] = wyrmi - 1 * -500
      entities[enid] = enteee
      lastseg = enid
    )
  ) else (
    newEntRaw2 id x y isboss
  )
)
def "newEntRaw2" "id,x,y,isboss" (
  // spawns an entity with
  // id, x, y, health, velocity_x, velocity_y, spawn_smoothing
  // then adds an extra one which is extras in an obj
  temp = [id, x, y, entity_health[id], 0, 0, 0]
  enid = ouidNew()
  entities[enid] = temp
  if isboss (
    window "add" window.file.uuid "ent" ++ ":" ++ enid
  )
)
def "newEnt" "id,x,y" (
  if entity_boss.contains(id) (
    newBossEnt id
  ) else (
    newEntRaw id x y
  )
)
def "newBorderEnt" "id" (
  side = random(1,4)
  switch side (
    case 1
      newEnt id winl random(wint,winb)
      break
    case 2
      newEnt id wint random(winl,winr)
      break
    case 3
      newEnt id winr random(wint,winb)
      break
    case 4
      newEnt id winb random(winl,winr)
      break
  )
)

def "newBossEnt" "id" (
  x = random(screensize_x * -.5 + 50, screensize_x * .5 - 50)
  y = random(screensize_y * -.5 + 50, screensize_y * .5 - 50)
  newEntRaw id x y true
)

def "newGoop" "gamt,gx,gy" (
  // spawns the blob with a bit of randomness depending
  // on how much big the blob is
  if amt >= 5 (
    gx += random(-100,100) / (amt * .75) * .5
    gy += random(-100,100) / (amt * .75) * .5
    goop.append([gamt,gx,gy])
  )
)

def "newGoopGroup" "amt,x,y" (
  // splits the goop into multiple spread out blobs
  left = amt
  while left > 0 (
    m = left
    if m > .1 * amt (
      m = .1 * amt
    )
    l = (m * 0.2).round
    if l < 1 (
      l = 1
    )
    takeamt = random(l,m).round
    newGoop takeamt x y
    left -= takeamt
  )
)

def "newEntBullet" "bx,by,bdir,bc,ben,bs" (
  if bs.type != "number" (
    local bs = 4
  )
  enbullets.append([bx,by,bdir,ouidNew(),bc,bs,ben])
)

def "newParticle" "par,px,py,pdir" (
  particles.append([par,px,py,pdir,0])
)

def "entTouch" "id" (
  player_health --
)
def "entDie" "id" (
  stat_enemies ++
  switch id (
    case "tri"
      newGoopGroup random(4,10).round * currencymult ex ey
      break
    case "circle"
      newGoopGroup random(8,16).round * currencymult ex ey
      break
    case "spiker"; case "wyrm"
      newGoopGroup random(20,30).round * currencymult ex ey
      break
  )
)

def ouidtonum(ouid) (
  num = 0
  each chari char ouid (
    num += chars.index(char) * (10 ^ (chari - 1))
  )
  return num / (10 ^ ouid.len) * 100
)
def lookat(x1,y1,x2,y2) (
  goto x1 y1
  pointat x2 y2
  dir = direction
  direction 90
  return dir
)
def "game_goto" "x,y" (
  goto x - window.x y - window.y
)

if passed_data == "" (
  //window "add" window.file.uuid "data"
  entities = {}
  goop = []
  
  //newEnt "tri" -10 0
  //newEnt "tri" 10 0
  
  bullets = []
  enbullets = []
  particles = []
  player_x = 0
  player_y = 0
  
  // performance (10 seems good)
  performance_collision = true
  performance_skipamt = 10
  
  // upgrades
  bullet_cooldown = 0
  bullet_uses = 1
  bullet_spread = 1
  player_speed = 3
  player_health = 10
  player_max_health = 10
  window_force = 7.5
  currency = 0
  currencymult = 1
  
  // stats
  stat_coins = 0
  stat_time = 0
  stat_bullets = 0
  stat_enemies = 0
  
  // window schtuff
  win_l_velocity = 0
  win_r_velocity = 0
  win_b_velocity = 0
  win_t_velocity = 0
  
  win_w_velocity = 0
  win_h_velocity = 0
  
  win_updateforcemult = 1.2
  
  bullet_cooldown_max = 40
  
  player_raw_x = 0
  player_raw_y = 0
  framei = 0
  timerstart = timer
  
  // entity stuff
  entity_width = {
    "tri": 30,
    "circle": 20,
    "spiker": 50,
    "wyrm": 60
  }
  entity_health = {
    "tri": 100,
    "circle": 20,
    "spiker": 200,
    "wyrm": 200
  }
  entity_touchHurt = [
    "tri",
    "circle",
    "spiker"
  ]
  entity_boss = [
    "spiker",
    "wyrm"
  ]
  
  // how many frames per spawn
  entity_spawnMax = {
    "tri":300,
    "circle": 350,
    "spiker": 6000,
    "wyrm": 6000
  }
  // limit for how fast they can spawn
  entity_spawnTop = {
    "tri":100,
    "circle":120,
    "spiker": 3000,
    "wyrm": 3000
  }
  // if the entity should spawn
  entity_shouldSpawn = {
    "tri": true, "circle": true, "spiker": true, "wyrm": true
  }
  each key entity_shouldSpawn.getKeys() (
    entity_shouldSpawn[key] = true
  )
  // spawn after this frame
  entity_spawnAfter = {
    "tri":100,
    "circle": 1000,
    "spiker": 4000,
    "wyrm": 7000
  }
  
  bulletTimerA = 0
  
  restockcost = 10
  entity_spawnTime = {}
  upgrade_levels = {}
  
  bullet_currenthit = {}
  bullet_lasthit = {}

  shop_open = false
  pause_open = false
  opened_shop_before = false
  winrestart = false
  realrestart = false
  timeshop = 0
  
  each upgrade upgrades.getKeys() (
    upgrade_levels[upgrade] = 1
  )
  
  each entity entity_spawnMax.getKeys() (
    entity_spawnTime[entity] = 0
  )
  
  //newBossEnt "spiker" 100 100
  //newBossEnt "spiker" 100 -100
  //newEnt "spiker" 100 100
  
  //newBossEnt "wyrm" 100 -100
)

chars = ["0","1","2","3","4","5","6","7","8","9","a","b","c","d","f"]

def "nothing" (;)

def "enemyC" "cr,cg,cb" (
  // so basically it turns (for each channel)
  // ff -> 255 -> + attack flash -> capped -> back to hex
  
  nothing
  
  local cr = hex.index(cr)
  local cg = hex.index(cg)
  local cb = hex.index(cb)
  if attackTime > 0 (
    local cr += attackTime * 2
    local cg += attackTime * 2
    local cb += attackTime * 2
    if cr > 256 (; local cr = 256; )
    if cg > 256 (; local cg = 256; )
    if cb > 256 (; local cb = 256; )
  )
  local col = "#" ++ hex[cr] ++ hex[cg] ++ hex[cb]
  c col
)

def "drawScene" "dentities,dbullets,denbullets,dgoop,dplayer_x,dplayer_y,d_particles,t" (
  // particles
  each particlei particle d_particles (
    switch particle[1] (
      case "hit"
        game_goto particle[2] particle[3]
        direction particle[4]
        icon "ellipse 0 0 2 2.9 90" 1.5 * (1 - (particle[5] / 15))
        break
    )
  )
  direction 90
  // entities (enemies)
  each entityi entitykey dentities.getKeys() (
    // boilerplate
    entity = dentities[entitykey]
    eid = entity[1]
    ex = entity[2]
    ey = entity[3]
    vx = entity[6]
    vy = entity[7]
    ext = entity[8]
    attackTime = ext["attackTime"]
    game_goto ex ey
    direction 90
    switch eid (
      case "tri"
        direction t * 30 + ouidtonum(entitykey)
        enemyC "FF" "CC" "00"
        icon "w 3 line 0 10 11.5 -10 cont -11.5 -10 cont 0 10" 1.7 * entity[5]
        break
      case "circle"
        enemyC "00" "EE" "EE"
        icon "w 2.5 cutcircle 0 0 7 0 180" 1.7 * entity[5]
        break
      case "spiker"
        enemyC "FF" "47" "65"
        icn = "w 1.3 line -5 10 0 14 cont 5 10 cont 12 12 cont 10 5 cont 14 0 cont 10 -5 cont 12 -12 cont 5 -10 cont 0 -14 cont -5 -10 cont -12 -12 cont -10 -5 cont -14 0 cont -10 5 cont -12 12 cont -5 10"
        icon icn 3.5 * entity[5]
        break
      case "wyrm"
        enemyC "FF" "47" "65"
        icn = "w 1 cutcircle 0 0 10 0 70 cutcircle 0 0 10 18 70 cutcircle 14.5 5.5 5.5 22 30 cutcircle 14.5 -5.5 5.5 -4 30 cutcircle -14.5 5.5 5.5 14 30 cutcircle -14.5 -5.5 5.5 4 30"
        icn = ext["ishead"] ? "w 1 cutcircle 0 0 10 0 180" icn
        direction ext["dir"] + 90
        icon icn 4 * entity[5]
        d = lookat(ex,ey,dplayer_x,dplayer_y)
        game_goto ex ey
        direction d
        change direction.sin() * 20 * entity[5] direction.cos() * 20 * entity[5]
        icon "w 1 cutcircle 0 0 2.8 0 180" 4 * entity[5]

        break
    )
  )
  
  // bullets
  each b dbullets (
    game_goto b[1] b[2]
    direction b[3]
    icon "w 5 ellipse 0 0 10 1.8 90 w 10 ellipse 0 0 4 2.8 90" .5 : c#fff
  )
  
  // entity bullets
  each eb denbullets (
    game_goto eb[1] eb[2]
    direction eb[3]
    if eb[5] == "wyrm" (
      icon "c #fff w 8 cutcircle 0 0 12 0 180 c #000 w 5 cutcircle 0 0 12 0 180" 1.4
    ) else (
      c eb[5]
      icon "w 4 cutcircle 0 0 8 0 180" .8
    )
  )

  
  // player
  game_goto dplayer_x dplayer_y
  icon "w 40 c #fff dot 0 0 w 30 c #" ++ window_colour ++ " dot 0 0" 1
  
  // yes the goop code is this simple, litterally just a dot
  each blob dgoop (
    game_goto blob[2] blob[3]
    icon "c #a935ff w 8 dot 0 0" blob[1]
  )
  
  direction 90
)

def "mainloop_main" (
  framei ++
  // sets stat_time for the death screen
  if player_health != -9999 (
    stat_time = (timer - timerstart).round
  )
  // player movement
  if player_health != -9999 (
    player_raw_x += ("d".isKeyDown() - "a".isKeyDown()) * player_speed
    if player_raw_x - 30 < winl (
      player_raw_x = winl + 30
    )
    if player_raw_x + 30 > winr (
      player_raw_x = winr - 30
    )
    player_x += player_raw_x - player_x * player_speed * .05
  
    player_raw_y += ("w".isKeyDown() - "s".isKeyDown()) * player_speed
    if player_raw_y - 30 < winb (
      player_raw_y = winb + 30
    )
    if player_raw_y + 30 > wint (
      player_raw_y = wint - 30
    )
    player_y += player_raw_y - player_y * player_speed * .05
  )
  bulletTimerA ++
  // entity spawning
  each entity entity_spawnTime.getKeys() (
    if framei >= entity_spawnAfter[entity] (
      if entity_shouldSpawn[entity] (
        if entity_spawnTime[entity] <= 0 (
          newBorderEnt entity
          // make it spawn more over time
          t = entity_spawnWait[entity] - (framei - (entity_spawnAfter[entity] + 0) * .01 * entity_spawnSub[entity])
          if t < entity_spawnMax[entity] (
            t = entity_spawnMax[entity]
          )
          entity_spawnTime[entity] = t
          // also spawns the entity more over time
          if entity_spawnTop.getKeys().contains(entity) (
            if entity_spawnMax[entity] > entity_spawnTop[entity] (
              entity_spawnMax[entity] -= random(5,12) / 10
            )
          )
        )
      )
    )
    entity_spawnTime[entity] -= random(5,15) / 10
  )
  
  // the entities (enemies)
  delentities = []
  each entityi entitykey entities.getKeys() (
    // boilerplate
    entity = entities[entitykey]
    eid = entity[1]
    ex = entity[2]
    ey = entity[3]
    vx = entity[6]
    vy = entity[7]
    if entity.len == 7 (
      entity.append({"attackTime":0})
    )
    game_goto ex ey
    entity[5] += (1 - entity[5]) * .05
    docollision = true
    // behaviour / update  
    switch eid (
      case "tri"
        edir = lookat(ex,ey,player_x,player_y)
        
        ex += edir.sin * 1.5
        ey += edir.cos * 1.5
        break
      case "circle"
        entity[8]["time"] --
        if entity[8]["time"] < 0 (
          edir = lookat(ex,ey,player_x,player_y)
          entity[8]["time"] = 50
          entity[8]["tarx"] = ex + (edir.sin * 300)
          entity[8]["tary"] = ey + (edir.cos * 300)
          entity[8]["varx"] = edir.sin * 20
          entity[8]["vary"] = edir.cos * 20
        ) else (
          vx += entity[8]["varx"] - vx * .05
          vy += entity[8]["vary"] - vy * .05
        )
        break
      case "spiker"
        if entity[8].getKeys().contains("timer").not (
          entity[8]["timer"] = 0
        ) 
        if entity[8]["timer"] == 0 (
          entity[8]["timer"] = 100
          for r 9 (
            newEntBullet ex ey r * 40 #ff4765 entitykey
          )
        )
        entity[8]["timer"] --
        break
      case "wyrm"
        //log entity[8]
        entity[8]["dir"] ??= 0
        entity[8]["localdir"] ??= 0
        entity[8]["timer"] ??= entity[8]["wyrmi"] * 15
        parent = entities[entity[8]["parent"]]
        parentdir = parent[8]["dir"]
        entity[8]["timer"] --
        if entity[8]["timer"] < 0 (
          entity[8]["timer"] = 100
          newEntBullet ex ey lookat(player_x,player_y,ex,ey) + 180 "wyrm" entitykey 6
        )
        if parent (
          enttimeyes = (timer * 120 + (entity[8]["wyrmi"] * -90)).toNum()
          entchangevar = (enttimeyes.sin().toNum() * 15)
          entity[8]["localdir"] = entchangevar
          entity[8]["dir"] += parentdir.toNum() + entity[8]["localdir"].toNum() - entity[8]["dir"] * .1
          ex = entity[8]["dir"].sin().toNum() * -150 + parent[2].toNum()
          ey = entity[8]["dir"].cos().toNum() * -150 + parent[3].toNum()
        ) else (
          entity[8]["tardir"] ??= random(0,360)
          if framei % 5 == 0 (
            entity[8]["tardir"] += random(-10,10)
          )
          entity[8]["localdir"] += entity[8]["tardir"] - entity[8]["localdir"] * .5
          entity[8]["dir"] += entity[8]["localdir"].toNum() - entity[8]["dir"] * .1
          ex += entity[8]["dir"].sin() * 3
          ey += entity[8]["dir"].cos() * 3
          if ey > (screensize_y * .5 - 80) (
            ey = (screensize_y * .5 - 80)
            entity[8]["tardir"] += 2
          )
          if ey < (screensize_y * -.5 + 80) (
            ey = (screensize_y * -.5 + 80)
            entity[8]["tardir"] += 2
          )
          if ex > (screensize_x * .5 - 80) (
            ex = (screensize_x * .5 - 80)
            entity[8]["tardir"] += 2
          )
          if ex < (screensize_x * -.5 + 80) (
            ex = (screensize_x * -.5 + 80)
            entity[8]["tardir"] += 2
          )
          if ey > (screensize_y * .5) - 100 and entity[8]["dir"] % 360 < 0 (
            entity[8]["tardir"] += 5
          )
          if ey < (screensize_y * -.5) + 80 + 100 and entity[8]["dir"] % 360 < 180 (
            entity[8]["tardir"] += 5
          )
          if ex > (screensize_x * .5) - 100 and entity[8]["dir"] % 360 < 90 (
            entity[8]["tardir"] += 5
          )
          if ex < (screensize_x * -.5) + 100 and entity[8]["dir"] % 360 < 270 (
            entity[8]["tardir"] += 5
          )
        )
        docollision = false
        break
    )
    // enemy death
    if entity[4] <= 0 (
      delentities.append(entitykey)
      sound "enemyDie" "play"
      entDie eid
    )
    // collision
    if performance_collision and docollision (
      if random(1,performance_skipamt) == 1 (
        each colentitykey entities.getKeys() (
          if entitykey != colentitykey (
            colentity = entities[colentitykey]
            colx = colentity[2]
            coly = colentity[3]
            d = dist(ex,ey,colx,coly)
            rads = (entity_width[eid] * .5) + (entity_width[colentity[1]]) + 10
            d -= rads
            if d < 0 (
              goto colx coly
              pointat ex ey
              dir = direction
              
              vx += dir.sin * d * -0.1 * performance_skipamt
              vy += dir.cos * d * -0.1 * performance_skipamt
            )
          )
        )
      )
    )
    
    // bounce and hurt the player
    if entity_touchHurt.contains(eid) and player_health != -9999 (
      colx = player_x
      coly = player_y
      d = dist(ex,ey,colx,coly) - 15
      rads = (entity_width[eid] * .5) + (25) + 10
      d -= rads
      if d < 0 (
        goto colx coly
        pointat ex ey
        dir = direction
        
        player_raw_x = dir.sin * -90 + player_x
        player_raw_y = dir.cos * -90 + player_y
        
        vx = dir.sin * 40
        vy = dir.cos * 40
        entTouch eid
        sound "enemyHit" "play"
      )
    )

    // updating the entity
    ex += vx * .2
    ey += vy * .2
    entity[2] = ex
    entity[3] = ey
    vx = vx * .95
    vy = vy * .95
    entity[6] = vx
    entity[7] = vy
    entity[8]["attackTime"] ??= 0
    entity[8]["attackTime"] -= 10
    entities[entitykey] = entity
  )
  // delete the entities given
  each reb delentities (
    entities.delete(reb)
  )

  // the bullets
  delbullets = []
  delbulletkeys = []
  each bulleti bullet bullets (
    bullets[bulleti][1] += bullet[3].sin * 10
    bullets[bulleti][2] += bullet[3].cos * 10
    
    x = bullets[bulleti][1]
    y = bullets[bulleti][2]
    bulletkey = bullet[4]
    // if the bullet hit the window borders
    if x < winl (
      delbullets.append(bulleti)
      win_l_velocity += window_force / bullet_spread
      delbulletkeys.append(bulletkey)
      if random(1,2) == 1 (; sound "hitWall" "play"; ) else (; sound "hitWall2" "play"; )
      loop 2 (; newParticle "hit" x y random(-40,40) + 90; )
    )
    if x > winr (
      delbullets.append(bulleti)
      win_r_velocity += window_force / bullet_spread
      delbulletkeys.append(bulletkey)
      if random(1,2) == 1 (; sound "hitWall" "play"; ) else (; sound "hitWall2" "play"; )
      loop 2 (; newParticle "hit" x y random(-40,40) - 90; )
    )
    if y < winb (
      delbullets.append(bulleti)
      win_b_velocity += window_force / bullet_spread
      delbulletkeys.append(bulletkey)
      if random(1,2) == 1 (; sound "hitWall" "play"; ) else (; sound "hitWall2" "play"; )
      loop 2 (; newParticle "hit" x y random(-40,40) + 0; )
    )
    if y > wint (
      delbullets.append(bulleti)
      win_t_velocity += window_force / bullet_spread
      delbulletkeys.append(bulletkey)
      if random(1,2) == 1 (; sound "hitWall" "play"; ) else (; sound "hitWall2" "play"; )
      loop 2 (; newParticle "hit" x y random(-40,40) + 180; )
    )
    // check if any enemies are getting hit
    each enti entkey entities.getKeys() (
      ent = entities[entkey]
      ex = ent[2]
      ey = ent[3]
      if dist(ex,ey,x,y) < (entity_width[ent[1]] - 5) (
        bullet_currenthit[bulletkey] = entkey
        if bullet_lasthit[bulletkey] != entkey (
          bullets[bulleti][5] += 1
          entities[entkey][4] -= random(25,50)
          entities[entkey][8]["attackTime"] = 100
          if bullet[5] >= bullet_uses - 1 (
            goto x y
            pointat ex ey
            dir = direction + 180
            loop 2 (
              newParticle "hit" x y random(-40,40) + dir
            )
          )
          if entities[entkey][4] > 0 (
            sound "enemyHit" "play"
          )
        )
      )
    )
    // piercing / delete the bullet if it has hit somthing
    if bullet[5] > bullet_uses - 1 (
      delbullets.append(bulleti)
      delbulletkeys.append(bullet[4])
    )
  )
  // delete the bullets given
  rbi = 0
  each rdbulleti rbb delbullets (
    bullets.delete(rbb - rbi)
    bullet_currenthit.delete(delbulletkeys[rbb - rbi])
    rbi ++
  )
  //log bullets.len
  
  bullet_lasthit = bullet_currenthit
  
  // the bullets
  endelbullets = []
  each enbulleti enbullet enbullets (
    enbullets[enbulleti][1] += enbullet[3].sin * enbullet[6]
    enbullets[enbulleti][2] += enbullet[3].cos * enbullet[6]
    
    x = enbullets[enbulleti][1]
    y = enbullets[enbulleti][2]
    enbulletkey = enbullet[4]
    parent = entities[enbullet[7]]
    parent_size = entity_width[parent[1]] + 40
    parent_x = parent[2]
    parent_y = parent[3]
    // if the bullet hit the window borders
    if ((x > winl and x < winr) or (x > parent_x - parent_size and x < parent_x + parent_size)).not (
      endelbullets.append(enbulleti)
      if random(1,2) == 1 (; sound "hitWall" "play"; ) else (; sound "hitWall2" "play"; )
    )
    if ((y > winb and y < wint) or (y > parent_y - parent_size and y < parent_y + parent_size)).not (
      endelbullets.append(enbulleti)
      if random(1,2) == 1 (; sound "hitWall" "play"; ) else (; sound "hitWall2" "play"; )
    )
    
    if dist(player_x,player_y,x,y) < 18 (
      endelbullets.append(enbulleti)
      player_health -- 
    )
  )
  // delete the bullets given
  rbi = 0
  each rdenbulleti rbb endelbullets (
    enbullets.delete(rbb - rbi)
    rbi ++
    sound "enemyHit" "play"
  )
  
  bullet_lasthit = bullet_currenthit

  
  // the goop (otherwise known as coins in windowkill)
  delgoop = []
  each blobi blob goop (
    bx = blob[2]
    by = blob[3]
    d = dist(player_x,player_y,bx,by)
    m = 400 - d
    m = m * m.abs
    m /= 300
    if m > 75 (
      m = 75
    )
    if m > 0 (
      dir = lookat(bx,by,player_x,player_y)
      goop[blobi][2] += dir.sin * m / 15 / (blob[1] / 9 + 1) * (blobi * .247536 % 1 + .5) * (player_speed / 3)
      goop[blobi][3] += dir.cos * m / 15 / (blob[1] / 9 + 1) * (blobi * .247536 % 1 + .5) * (player_speed / 3)
      if d < 25 (
        delgoop.append(blobi)
        currency += blob[1]
        stat_coins += blob[1]
        n = "blob" ++ random(1,5)
        sound n "play"
      )
    )
  )
  // delete the goop given
  rgi = 0
  each rg2i rgb delgoop (
    goop.delete(rgb - rgi)
    rgi ++
  )
  
  // particles
  delpar = []
  each particlei particle particles (
    particle[2] += particle[4].sin() * 5
    particle[3] += particle[4].cos() * 5
    particle[5] += 1
    deathTime = 10
    switch particle[1] (
      case "hit"
        deathTime = 15
        break
    )
    if particle[5] > deathTime (
      delpar.append(particlei)
    )
    particles[particlei] = particle
  )
  // delete the goop given
  rgi = 0
  each rg2i rgb delpar (
    particles.delete(rgb - rgi)
    rgi ++
  )


  // bullet fireing
  if bullet_cooldown <= 0 and mouse_down and player_health != -9999 (
    bullet_cooldown = bullet_cooldown_max
    
    // basically [player_x,player_y].lookat([mouse_x,mouse_y])
    game_goto player_x player_y
    pointat mouse_x mouse_y
    dir = direction
    
    sp = 1 / bullet_spread
    for spreadi bullet_spread (
      bul_dir = dir
      bul_dir += (spreadi - 1 * 2 * sp) + sp - 1 * 20
      stat_bullets ++
      // mist hasnt added [player_x,player_y,bul_dir,ouidNew(),0] so :/
      bullets.append([].append(player_x).append(player_y).append(bul_dir).append(ouidNew()).append(0))
    )
    
    sound "shoot" "play"
  )
  
  bullet_cooldown --
  spawntimer --
  
  direction 90
)

def "win_update" (
  // bounce the window off the edges
  if framei > 200 (
    if winl < (screensize_x * -.5) (
      win_l_velocity *= .95
      win_l_velocity -= (screensize_x * -.5) - winl * .1
    )
    if winr > (screensize_x * .5) (
      win_r_velocity *= .95
      win_r_velocity += (screensize_x * .5) - winr * .1
    )
    if winb < (screensize_y * -.5 + 80) (
      win_b_velocity *= .95
      win_b_velocity -= (screensize_y * -.5 + 80) - winb * .1
    )
    if wint > (screensize_y * .5) (
      win_t_velocity *= .95
      win_t_velocity += (screensize_y * .5) - wint * .1
    )
  )
  
  // framei < 200 is the window shrinking to the resting size
  win_x = winl + winr / 2
  win_y = winb + wint / 2
  win_width = winr - winl
  win_height = wint - winb
  if framei < 200 (
    win_w_velocity += 400 - win_width / 150
    win_h_velocity += 400 - win_height / 150
    win_width += win_w_velocity * .25
    win_height += win_h_velocity * .25
    win_w_velocity *= .95
    win_h_velocity *= .95
  ) else (
    win_w_velocity += 350 - win_width / 2500 * win_updateforcemult
    win_h_velocity += 350 - win_height / 2500 * win_updateforcemult
    win_width += win_w_velocity * .5
    win_height += win_h_velocity * .5
    win_w_velocity *= .95
    win_h_velocity *= .95
  )
  
  // update the window
  window.x = win_x
  window.y = win_y
  window.width = win_width
  window.height = win_height
)
def "win_setup" (
  // window logic (the movement)
  winl = window.x + (window.width * -.5)
  winr = window.x + (window.width * .5)
  winb = window.y + (window.height * -.5)
  wint = window.y + (window.height * .5)
  
  winl += win_l_velocity * -1
  winr += win_r_velocity * 1
  winb += win_b_velocity * -1
  wint += win_t_velocity * 1
  
  win_l_velocity *= .9
  win_r_velocity *= .9
  win_b_velocity *= .9
  win_t_velocity *= .9
)

shopsmooth = [0,0,0]
restocksmooth = 0
if wintype == "" (
  shopitems = []
  shoplocked = []
  shoplockedlerp = []
  loop 3 (
    shopitems.append(upgrades.getKeys()[random(1,upgrades.len)])
    shoplocked.append(false)
    shoplockedlerp.append(0)
  )
  //win_setup
)

space_last = "space".isKeyDown()
window "show"
mouse_right_last = false
framecounter2 = 0
mainloop:
  window "refresh_bg"
  framecounter2 ++
  click_right = mouse_right and mouse_right_last.not
  mouse_right_last = mouse_right
  window_colour = #040404
  win_setup
  // basically if the main window is saying its dying, die youself
  if window.parent.file_uuid == window.file.uuid (
    if window.parent.variables.winrestart (
      window "stop"
    )
  ) else (
    if realrestart (
      // restart the window :P
      window "add" window.file.uuid
      window "stop"
    ) else (
      if winrestart (
        window "stop"
      )
    )
  )
  if window.parent (
    if window.parent.variables.framecounter2 (
      if window.parent.variables.framecounter2 > 10 and framecounter2 > 2 (
        if lastframe1 == lastframe2 and lastframe2 == lastframe3 and lastframe3 == lastframe4 and lastframe4 == lastframe5 (
          window "stop"
        )
        lastframe5 = lastframe4
        lastframe4 = lastframe3
        lastframe3 = lastframe2
        lastframe2 = lastframe1
        lastframe1 = window.parent.variables.framecounter2
      )
    )
  )
  if wintype == "" (
    // cap the playe rhealth
    if player_health > player_max_health (
      player_health = player_max_health
    )
    // run the game logic if ur not in a menu
    if shop_open.not and pause_open.not (
      mainloop_main
    )
    // quick note: player_health != -9999 or if its -9999 it means the
    // player is dead and the game is still "playing"
    if player_health != -9999 (
      drawScene entities bullets enbullets goop player_x player_y particles timer
    ) else (
      drawScene entities bullets enbullets goop 9999 9999 particles timer
    )
    // spawn the menus if u press the buttons
    if dead_open.not (
      if "space".isKeyDown() and space_last.not (
        if shop_open.not (
          window "add" window.file.uuid "shop"
          opened_shop_before = true
        )
        shop_open = shop_open.not
      )
      space_last = "space".isKeyDown()
      if "escape".isKeyDown() and pause_last.not (
        if pause_open.not (
          window "add" window.file.uuid "pause"
        )
        pause_open = pause_open.not
      )
      pause_last = "escape".isKeyDown()
    )
    
    // currecny
    loc 2 2 15 -20
    icon "c #a935ff w 10 dot 0 0" 1
    text currency 12 : c#a935ff chx#10
    
    if player_health != -9999 (
      // health / max text
      loc -2 2 -10 -20
      t = player_health ++ "/" ++ player_max_health
      change_x t.len * -12
      c #fff
      if player_health <= 2 (
        if timer * 4 % 1 < .5 (
          c #f66
        )
      )
      text t 12
      
      if shop_open.not and pause_open.not (
        win_update
      )
    )
    
    if opened_shop_before.not (
      if timer - timerstart > 15 and currency > 0 (
        presstoopenshopT ??= 0
        presstoopenshopT += 1 - presstoopenshopT * .05
        if presstoopenshopT > 1 (
          presstoopenshopT = 1
        )
        loc 9999 -2 "press [space] to open shop".len * -5 -15 + (presstoopenshopT * 30)
        text "press [space] to open shop" 10 : c#454545
      )
    )
    
    win_sx = window.width
    win_sy = window.height
    win_px = window.x
    win_py = window.y
    // spawn the dead menu if the player is dead
    if player_health <= 0 and player_health != -9999 (
      window "add" window.file.uuid "dead"
      dead_open = true
      shop_open = false
      player_health = -9999
    )
    // music
    if "ost1".soundinfo("playing").not and play_ost (
      sound "ost1" "play"
    )
  )    
  if wintype == "shop" (
    // window boilerplate
    v @= window.parent.variables
    if v.shop_open.not (
      window "stop"
    )
    // render the game in this window
    game_goto v.win_px v.win_py
    square v.win_sx v.win_sy 16 : c#151515
    square v.win_sx v.win_sy 10 : c#040404
    
    drawScene v.entities v.bullets v.enbullets v.goop v.player_x v.player_y v.particles timer
    
    // transparent tint
    c #000
    pen "size" 100000
    pen "opacity" 70
    pen "down"
    pen "up"
    
    // currency
    loc 9999 9999 (v.currency ++ "").len * -10 - 5 150
    icon "c #a935ff w 10 dot 0 0" 1
    text v.currency 20 : c#a935ff chx#10
    
    // each upgrade, but its called panel for some reason
    for panel_i 3 (
      goto -150 + (panel_i-1 * 150) 0
      
      square 120 120 15 0 1
      
      shopsmooth[panel_i] += (mouse_touching ? 1 0) - shopsmooth[panel_i] * .3
      
      itm = v.shopitems[panel_i]
      upgrade = v.upgrades[itm]
      
      // buying the upgrade
      if onclick (
        if v.currency >= upgrade[1] (
          v.currency -= upgrade[1]
          v.upgrade_levels[itm] ++
          shopsmooth[panel_i] = 0
          v.shopitems[panel_i] = upgrades.getKeys()[random(1,upgrades.len)]
          v.upgrades[itm][1] *= random(18,35) / 10
          v.upgrades[itm][1] = v.upgrades[itm][1].round
          arr = []
          v.shoplocked[panel_i] = false
          if upgrade[2].type == "array" (
            each cng upgrade[2] (
              arr.append("v." ++ cng[1] + cng[2] ++ "=" + cng[3])
            )
          ) else (
            arr.append("v." ++ upgrade[2] + upgrade[3] ++ "=" + upgrade[4])
          )
          run arr
        )
      )
      
      if click_right and mouse_touching (
        v.shoplocked[panel_i] = v.shoplocked[panel_i].not
      )
      
      l = v.shoplockedlerp[panel_i]
      l += (v.shoplocked[panel_i] ? 1 0) - l * .2
      if l > 1 (
        l = 1
      )
      if l < 0 (
        l = 0
      )
      v.shoplockedlerp[panel_i] = l
      
      change_y shopsmooth[panel_i] * 20
      
      // cost label
      sx = x_position
      change_x (upgrade[1] ++ "").len * -6 - 5
      if v.currency >= upgrade[1] (
        c #a935ff
      ) else (
        c #f22
      )
      icon "w 10 dot 0 0" 1 : chy#-90
      text upgrade[1] 12 : chx#10
      set_x sx
      change_y 90
      
      // lv. label
      if actions.contains(itm).not (
        sx = x_position
        txt = "lv." + v.upgrade_levels[itm]
        change_x (txt ++ "").len * -6
        text txt 12 : c#fff chy#90
        set_x sx
        change_y -90
      )
      
      c = #fff
      if v.currency < upgrade[1] (
        c = #222
      )
      
      square 120 120 15 : c#c
      square 120 120 10 : c#040404
      
      // icon
      if true "icn = up_" ++ itm
      icon icn 3 : chy#10
      
      // text
      txt = itm
      if upgrade_text.getKeys().contains(txt) (
        txt = upgrade_text[txt]
      )
      change_x txt.len * -5
      text txt 10 : c#fff chy#-60
      
      tempicn = "w 3 square 0 -4.5 6 4 line -4 1 -4 3 cutcircle 0 5 4 0 80 cont 4 1"
      
      set_x sx
      change 50 100
      if v.shoplockedlerp[panel_i] > .1 (
        icon tempicn v.shoplockedlerp[panel_i]
      )
    )
    set_x 0
    set_y -150
    
    // restock code (but wait theres more)
    c = #fff
    if v.currency < v.restockcost (
      c = #222
    )
    
    // restock (yes this is all the restock button code)
    square 120 20 15 0 1
    if mouse_touching (
      if onclick and v.currency >= v.restockcost (
        v.currency -= v.restockcost
        shopitems = []
        u = v.upgrades.getKeys()
        for ii 3 (
          r = random(1,u.len)
          if v.shoplocked[ii] (
            shopitems.append(v.shopitems[ii])
          ) else (
            shopitems.append(u[r])
          )
        )
        v.shopitems = shopitems
        restocksmooth = 0
        v.restockcost *= 1.4
        v.restockcost = v.restockcost.round
      )
    )
    restocksmooth += (mouse_touching ? 1 0) - restocksmooth * .3
    change_y restocksmooth * 20
    square 120 20 15 : c#c
    square 120 20 10 : c#040404
    sx = x_position
    change_x "restock".len * -5
    text "restock" 10 : c#fff
    set_x sx
    change_x (v.restockcost ++ "").len * -6 - 5
    if v.currency >= v.restockcost (
      c #a935ff
    ) else (
      c #f22
    )
    icon "w 10 dot 0 0" 1 : chy#-35
    text v.restockcost 12 : chx#10
    set_x sx
    
    window "dimensions" 700 450
    window "resizable" false
  )
  if wintype == "dead" (
    // window boilerplate
    v @= window.parent.variables
    if v.dead_open.not (
      window "stop"
    )
    
    // render the game in this window
    game_goto v.win_px v.win_py
    square v.win_sx v.win_sy 16 : c#151515
    square v.win_sx v.win_sy 10 : c#040404
    
    drawScene v.entities v.bullets v.enbullets v.goop 9999 9999 v.particles timer
    
    // transparent tint
    c #000
    pen "size" 100000
    pen "opacity" 70
    pen "down"
    pen "up"
    
    loc 9999 9999 "game over".len * -14 80
    text "game over" 28 : c#fff
    change_y -10
    
    txt = "coins collected:" + v.stat_coins
    loc 9999 9999 txt.len * -5.5 80
    text txt 11 : c#fff chy#-50
    
    txt = "time survived:" + v.stat_time + "seconds"
    loc 9999 9999 txt.len * -5.5 80
    text txt 11 : c#fff chy#-80
    
    txt = "bullets fired:" + v.stat_bullets
    loc 9999 9999 txt.len * -5.5 80
    text txt 11 : c#fff chy#-110
    
    txt = "enemies killed:" + v.stat_enemies
    loc 9999 9999 txt.len * -5.5 80
    text txt 11 : c#fff chy#-140
    
    txt = "press [space] to try again"
    loc 9999 9999 txt.len * -4.5 80
    text txt 9 : c#555 chy#-170
    
    window "dimensions" 480 400
    window "resizable" false
    
    if "space".isKeyDown() (
      v.winrestart = true
      v.realrestart = true
    )
  )
  if wintype == "pause" (
    // window boilerplate
    v @= window.parent.variables
    if v.pause_open.not (
      window "stop"
    )

    // render the game in this window
    game_goto v.win_px v.win_py
    square v.win_sx v.win_sy 16 : c#151515
    square v.win_sx v.win_sy 10 : c#040404
    
    drawScene v.entities v.bullets v.enbullets v.goop v.player_x v.player_y v.particles timer
    
    // transparent tint
    c #000
    pen "size" 100000
    pen "opacity" 70
    pen "down"
    pen "up"
    
    goto "ORIGINKILL".len * -15 100
    text "ORIGINKILL" 30 : c#fff
    
    goto "ORIGINKILL".len * -15 - 10 70
    icon "line 0 10 0 0 cont 10 0" 1
    goto "ORIGINKILL".len * 15 + 10 70
    icon "line 0 10 0 0 cont -10 0" 1
    goto "ORIGINKILL".len * -15 - 10 130
    icon "line 0 -10 0 0 cont 10 0" 1
    goto "ORIGINKILL".len * 15 + 10 130
    icon "line 0 -10 0 0 cont -10 0" 1
    
    quitsmooth ??= 0
    goto 0 -100
    square 120 20 15 0 1
    if mouse_touching (
      if onclick (
        v.winrestart = true
      )
    )
    quitsmooth += (mouse_touching ? 1 0) - quitsmooth * .3
    change_y quitsmooth * 20
    square 120 20 15 : c#fff
    square 120 20 10 : c#040404
    change_x "quit".len * -5
    text "quit" 10 : c#fff
    
    window "resizable" false
  )
  if wintype.split(":")[1] == "ent" (
    // window boilerplate
    v @= window.parent.variables
    
    // code
    followEnt = v.entities[wintype.split(":")[2]]
    if followEnt == "" (
      window "stop"
    )
    //log followEnt
    drawScene v.entities v.bullets v.enbullets v.goop v.player_x v.player_y v.particles timer
    s = v.entity_width[followEnt[1]] * 2 + 50 * followEnt[5]
    window "dimensions" s s
    window.x = followEnt[2]
    window.y = followEnt[3]
    window "set_dragbox" [[0,0,0,0],[0,0,0,0]]
    window "resizable" false
  )
window "show"
